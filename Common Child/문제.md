# 일반 어린이

문자열은 다른 문자열에서 0개 이상의 문자를 삭제하여 만들 수 있는 경우 다른 문자열의 하위라고 합니다. 길이가 같은 두 개의 문자열이 주어지면 두 문자열의 자식인 것처럼 긴 문자열을 구성할 수 있습니까?

예를 들어 ABCD와 ABDC는 최대 길이가 3인 ABC와 ABD라는 두 명의 자식을 갖습니다. 두 줄 모두에서 D 또는 C를 제거하여 형성할 수 있습니다. 문자와 ABCD $\neq$ ABDC를 재배열 할 수 없으므로 우리는 ABCD를 일반적인 어린이로 간주하지 않습니다.

## 함수 설명

아래 에디터에서 commonChild 함수를 완성하십시오. 입력 문자열의 가장 일반적인 문자열인 가장 긴 문자열을 반환 해야 합니다.

common Child에는 다음과 같은 매개 변수가 있습니다.

* s1, s2 : 두 개의 같은 길이의 문자열

## 입력 형식

두 개의 공백으로 구분된 문자열인 $s1$과 $s2$가 있는 한 줄이 있습니다.

## 제약 조건

* $1 \leq |s1|, |s2| \leq 5000$
* 모든 문자는 ascii[A-Z] 범위의 대문자입니다.

## 출력 형식

$s$가 $s1$과 $s2$의 자식이되도록 가장 긴 문자열 $s$의 길이를 인쇄하십시오.

## 샘플 입력

```text
HARRY
SALLY
```

## 샘플 출력

```text
2
```

## 설명

$HARRY$ 및 $SALLY$에서 0개 이상의 문자를 삭제하여 형성할 수 있는 가장 긴 문자열은 길이가 2인 $AY$입니다.

## 샘플 입력 1

```text
AA
BB
```

## 샘플 출력 1

```text
0
```

## 설명 1

$AA$와 $BB$에는 공통적인 문자가 없으므로 출력은 0입니다.

## 샘플 입력 2

```text
SHINCHAN
NOHARAAA
```

## 샘플 출력 2

```text
3
```

## 설명 2

순서를 유지하면서 $SHINCHAN$과 $NOHARAAA$ 사이에 형성될 수 있는 가장 긴 끈은 $NHA$입니다.

## 샘플 입력 3

```text
ABCDEF
FBDAMN
```

## 샘플 출력 3

```text
2
```

## 설명 3

$BD$는 주어진 문자열에서 가장 긴 자식입니다.

## 해결책

동적 프로그래밍 기법을 사용한다.:

```pseudo
dp[s1.length + 1][s2.length + 1];
For (i = 0; i < s1.length; ++i)
{
    For (j = 0; j < s2.length; ++j)
    {
        If (s1[i] == s2[j])
            dp[i + 1][j + 1] = dp[i][j] + 1;
        Else
            dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
    }
}

return dp[s1.length][s2.length];
```