# 교환 노드 [Algo]

이진 트리는 다음 속성 중 하나를 특징으로 하는 트리입니다.

* 비어있을 수 있습니다. (null).
* 하나의 루트 노드만 포함합니다.
* 왼쪽 하위 트리, 오른쪽 하위 트리 또는 둘 다 하나의 루트 노드가 포함됩니다. 이 하위 트리는 이진 트리이기도 합니다.

순차 순회는 다음과 같이 수행됩니다.

1. 왼쪽 하위 트리를 탐색합니다.
2. 루트를 방문하십시오.
3. 오른쪽 하위 트리를 탐색하십시오.

이 순서 순회를 위해, 루트 노드의 왼쪽 하위 노드에서 시작하여 리프에 도달할 때까지 왼쪽 하위 트리를 계속 탐색합니다. 잎에 닿았을 때 부모에게 등을 돌리고 올바른 아이를 확인한 다음 앞이 있으면 방문하십시오. 자식이 없으면 왼쪽 및 오른쪽 하위 트리를 완전히 탐색했습니다. 올바른 아이가 있는 경우 왼쪽 하위 트리를 통과한 다음 같은 방식으로 오른쪽 하위 트리를 탐색합니다. 전체 트리를 통과할 때까지 이 작업을 계속하십시오. 다음 중 하나가 참일 때 방문 할 때만 노드의 값을 저장합니다.

* 방문한 첫 번째 노드이며 처음 방문한 노드입니다.
* 그것은 나뭇잎이며 한 번만 방문해야 합니다.
* 모든 하위 트리를 탐험했으며 이것이 사실일 때만 한 번 방문해야 합니다.
* 그것은 처음 방문한 나무의 뿌리다.

**교환:** 노드의 하위 트리 교환은 처음 노드가 하위 트리 L과 오른쪽 하위 트리 R을 남기고 맞교환한 후 왼쪽 하위 트리가 R이고 오른쪽 하위 트리가 L인 것을 의미합니다.

예를 들어 다음 트리에서는 노드 1의 하위 노드를 서로 바꿉니다.

```text
                                Depth
    1               1            [1]
   / \             / \
  2   3     ->    3   2          [2]
   \   \           \   \
    4   5           5   4        [3]
```

왼쪽 트리의 순차 트래버스는 2 4 1 3 5이고 오른쪽 트리의 순차 트래킹은 3 5 1 2 4입니다.

**교환 작업**:

노드의 깊이를 다음과 같이 정의합니다.

* 루트 노드는 깊이 1에 있습니다.
* 상위 노드의 깊이가 d이면 현재 노드의 깊이는 d + 1이 됩니다.

하나의 연산에서 트리와 정수 k가 주어지면 각 깊이 h에서 모든 노드의 하위 트리를 교환해야 합니다. 여기서 h ∈ [k, 2k, 3k, ...]입니다. 즉, h가 k의 배수이면 해당 수준의 왼쪽 및 오른쪽 하위 트리를 교환합니다.

노드가 [1..n]에서 색인이 생성되고 n은 1의 루트가 되는 n 노드의 트리가 주어집니다. t 교환 연산을 수행하고 각 교환 연산 후에 현재 나무의 상태 순회 트래킹을 인쇄합니다.

## 함수 설명

아래 편집기에서 swapNodes 함수를 완성하십시오. 그것은 2차원 배열을 반환해야 하는데, 각 요소는 교환 연산 이후에 순차 탐색의 노드 인덱스를 나타내는 정수의 배열입니다.

swapNodes에는 다음과 같은 매개 변수가 있습니다.\
\- indexes: 첫 번째 요소로 시작하는 각 인덱스 값을 나타내는 정수 배열을 루트로 사용합니다.\
\- queries: 각각 값을 나타내는 정수의 배열.

## 입력 형식

첫 번째 줄에는 n 개의 트리에 있는 노드 수가 들어 있습니다.

다음 n 행은 각각 두 개의 정수 a b를 포함합니다. 여기서 a는 왼쪽 자식의 색인이고 b는 i 번째 노드의 오른쪽 하위 색인입니다.

**주:** 널 노드를 나타내기 위해 -1이 사용됩니다.

다음 행에는 $queries$의 크기인 정수 t가 들어 있습니다.\
다음 t 행들 각각은 정수 $queries[i]$를 포함하는데, 각각은 값 $k$이다.

## 출력 형식

각 k에 대해 교환 연산을 수행하고 순서 순회의 색인을 결과 배열에 저장합니다. 모든 교환 작업이 수행된 후 결과 배열을 인쇄하여 반환하십시오.

## 제약 조건

* $1 ≤ n ≤ 1024$
* $1 ≤ t ≤ 100$
* $1 ≤ k ≤ n$
* $a = -1$ 또는 $2 <= a <= n$
* $b = -1$ 또는 $2 <= b <= n$
* null 이외 아이의 인덱스는 항상 그 부모의 인덱스보다 커집니다.

## 샘플 입력 0

```text
3
2 3
-1 -1
-1 -1
2
1
1
```

## 샘플 출력 0

```text
3 1 2
2 1 3
```

## 설명 0

노드 2와 노드 3에는 자식이 없으므로 맞교환은 아무런 영향을 미치지 않습니다. 루트 노드의 자식 노드만 바꾸면 됩니다.

```text
    1   [s]       1    [s]       1
   / \      ->   / \        ->  / \  
  2   3 [s]     3   2  [s]     2   3
```

**참고:** [s]는 이 깊이에서 교환 작업이 완료되었음을 나타냅니다.

## 샘플 입력 1

```text
5
2 3
-1 4
-1 5
-1 -1
-1 -1
1
2
```

## 샘플 출력 1

```text
4 2 1 5 3
```

## 설명 1

노드 2와 노드 3의 자식 노드를 서로 바꾼다.

```text
    1                  1  
   / \                / \
  2   3   [s]  ->    2   3
   \   \            /   /
    4   5          4   5  
```

## 샘플 입력 2

```text
11
2 3
4 -1
5 -1
6 -1
7 8
-1 9
-1 -1
10 11
-1 -1
-1 -1
-1 -1
2
2
4
```

## 샘플 출력 2

```text
2 9 6 4 1 3 7 5 11 8 10
2 6 9 4 1 3 7 5 10 8 11
```

## 설명 2

여기서 우리는 $K = 2$일 때 깊이가 2 또는 4인 노드에서 그리고 $K = 4$일 때 깊이가 4인 노드에서 교환 연산을 수행합니다.

```text
         1                     1                          1
        / \                   / \                        / \
       /   \                 /   \                      /   \
      2     3    [s]        2     3                    2     3
     /      /                \     \                    \     \
    /      /                  \     \                    \     \
   4      5          ->        4     5          ->        4     5
  /      / \                  /     / \                  /     / \
 /      /   \                /     /   \                /     /   \
6      7     8   [s]        6     7     8   [s]        6     7     8
 \          / \            /           / \              \         / \
  \        /   \          /           /   \              \       /   \  
   9      10   11        9           11   10              9     10   11
```

## 해결책

트리를 구현하고 DPS를 통해 깊이를 구한 뒤 계산한다.